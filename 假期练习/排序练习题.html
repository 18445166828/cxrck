<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        //快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。
        // 比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。
        // 然后将数组以基准值的位置分为两部分，继续递归以上操作。

        function quickSort(array){
            const sort = (arr, left = 0, right = arr.length - 1) => {
                if (left >= right) {
                    return
                }
                let i = left;
                let j = right;
                let baseVal = arr[j];
                while (i < j) {
                    if (i < j && arr[i] <= baseVal) {
                        i++
                    }
                    arr[j] = arr[i];
                    if (j > i && arr[j] >= baseVal) {
                        j--
                    }
                    arr[i] = arr[j]
                }
                arr[j] = baseVal;
                sort(arr, left,  j - 1);
                sort(arr, i + 1, right);
            }
            const newarray = array.concat()
            sort(newarray)
            return newarray;
        }
        console.log(quickSort([2, 1, 31, 6, 4, 7]));

        // 选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，
        // 遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，
        // 下次遍历就可以从索引 1 开始重复上述操作。
        function select(arr) {
            for (let i = 0; i < arr.length - 1; i++) {
                let min = i;
                for (let j = i; j < arr.length; j++) {
                    if (arr[j] < arr[min]) {
                        min = j;
                    }
                }
                if (i != min) {
                    [arr[i], arr[min]] = [arr[min], arr[i]]
                }
            }
            return arr
        }
        console.log(select([2, 1, 31, 6, 4, 7]));

        // 冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，
        // 那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。
        // 下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要
        // 比较到 length - 1 的位置。
        function bubble(arr) {
            for (let i = arr.length - 1; i >= 0; i--) {
                for (let j = 0; j < i; j++) {
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
                    }
                }
            }
            return arr
        }
        console.log(bubble([2, 1, 31, 6, 4, 7]))

        //  插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换
        //  位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。
        function insert(arr) {
            for (let i = 1; i < arr.length; i++) {
                for (let j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--)
                    [arr[j],arr[j+1]]=[arr[j+1],arr[j]]
            }
            return arr;
        }
        console.log(insert([2, 1, 31, 6, 4, 7]))
    </script>

</body>

</html>